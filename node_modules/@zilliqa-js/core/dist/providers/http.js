"use strict";
//  Copyright (C) 2018 Zilliqa
//
//  This file is part of Zilliqa-Javascript-Library.
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var base_1 = require("./base");
var net_1 = require("../net");
var util_1 = require("../util");
var HTTPProvider = /** @class */ (function (_super) {
    tslib_1.__extends(HTTPProvider, _super);
    function HTTPProvider() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    HTTPProvider.prototype.buildPayload = function (method, params) {
        return {
            url: this.nodeURL,
            payload: { id: 1, jsonrpc: '2.0', method: method, params: params },
        };
    };
    HTTPProvider.prototype.buildBatchPayload = function (method, paramsList) {
        var e_1, _a;
        var payloads = [];
        try {
            for (var paramsList_1 = tslib_1.__values(paramsList), paramsList_1_1 = paramsList_1.next(); !paramsList_1_1.done; paramsList_1_1 = paramsList_1.next()) {
                var payloadParam = paramsList_1_1.value;
                var params = [payloadParam];
                payloads.push({
                    id: 1,
                    jsonrpc: '2.0',
                    method: method,
                    params: params,
                });
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (paramsList_1_1 && !paramsList_1_1.done && (_a = paramsList_1.return)) _a.call(paramsList_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return {
            url: this.nodeURL,
            payload: payloads,
        };
    };
    HTTPProvider.prototype.send = function (method) {
        var params = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            params[_i - 1] = arguments[_i];
        }
        var _a = tslib_1.__read(this.getMiddleware(method), 2), tReq = _a[0], tRes = _a[1];
        var reqMiddleware = util_1.composeMiddleware.apply(void 0, tslib_1.__spread(tReq));
        var resMiddleware = util_1.composeMiddleware.apply(void 0, tslib_1.__spread(tRes));
        var req = reqMiddleware(this.buildPayload(method, params));
        return net_1.performRPC(req, resMiddleware);
    };
    HTTPProvider.prototype.sendBatch = function (method, params) {
        var _a = tslib_1.__read(this.getMiddleware(method), 2), tReq = _a[0], tRes = _a[1];
        var reqMiddleware = util_1.composeMiddleware.apply(void 0, tslib_1.__spread(tReq));
        var resMiddleware = util_1.composeMiddleware.apply(void 0, tslib_1.__spread(tRes));
        var batchPayload = this.buildBatchPayload(method, params);
        var req = reqMiddleware(batchPayload);
        return net_1.performBatchRPC(req, resMiddleware);
    };
    HTTPProvider.prototype.subscribe = function (event, subscriber) {
        throw new Error('HTTPProvider does not support subscriptions.');
    };
    HTTPProvider.prototype.unsubscribe = function (token) {
        throw new Error('HTTPProvider does not support subscriptions.');
    };
    return HTTPProvider;
}(base_1.BaseProvider));
exports.HTTPProvider = HTTPProvider;
//# sourceMappingURL=http.js.map